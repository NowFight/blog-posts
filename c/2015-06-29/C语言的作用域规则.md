## 作用域规则

程序中名字的作用域，通俗的讲，就是这个名字在程序中的使用范围。在C语言中，作用域的规则相对比较简单，主要分为 **全局作用域** 和 **局部作用域** 两种。

一个变量如果定义在函数中，那么这个变量的作用域就是一个局部作用域，在函数外面不能访问这个变量。在别的函数中定义同名的变量，也不会出现名字冲突，因为它们都处于各自的局部作用域中。

外部变量或函数的作用域是从声明的位置开始，到所在文件的末尾。如果需要在别的文件中引用不在这个文件中定义的外部变量，或者在这个变量定义之前使用，可以通过关键字 *extern* 进行声明。

*extern *修饰符的作用是，告知该变量已经在别的地方定义了。外部变量和函数默认具有全局作用域，所以可以在程序的任何位置进行引用。

~~~c

main() { ... }
int sp = 0;
double val[MAXVAL];
void push(double f) { ... }
double pop(void) { ... }

~~~

在上面的代码中，sp和val的作用域是从它们定义的位置开始的，所以可以在push和pop函数中引用这两个变量。而在main函数中，不能直接引用这两个变量。如果需要引用在后面定义的变量，可以使用关键字 *extern* 声明需要使用的变量。在上面的代码中，如果需要在main中使用sp，则可以这样声明：

~~~c

extern int sp;

~~~

> 声明和定义的区别：声明只是告知这个变量的类型，而定义一个变量，除了告知变量的类型，还会为变量分配存储空间。

在一个程序中，外部变量的定义只能有一处，而外部变量的声明可以出现在任何需要引用这个变量的文件中。通过在文件中使用 *extern* 关键字声明一个变量，可以使用在别的地方声明的变量。

## static修饰符

在C语言中，static修饰符用于定义静态变量。static除了可以修饰变量外，还可以修饰函数。

对于外部变量和函数，static修饰符会限制它们的作用域，使它们只能在定义它们的文件中使用，作用域不能传播到文件外。

使用static修饰符，提供了一种隐藏名字的方式，可以将名字限定在一个文件中，防止名字冲突。

~~~c

static char buf[BUFSIZE];
static int bufp = 0;
int getch(void) { ... }
void ungetch(int c) { ... }

~~~

在上面的代码中，bufp和buf都只能在函数getch和ungetch中使用，而不能在别的文件中使用，即使在别的文件中使用了extern声明。

static修饰符除了可以修饰外部变量和函数外，也可以作用于局部变量。通过static修饰的局部变量，在函数中的存储空间将不会再函数结束后销毁，而是一直存在直到程序结束。当程序再次被调用时，仍旧可以访问这个区域的内存。